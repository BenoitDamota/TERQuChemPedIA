\subsection{Présentation}
Dans le but de pouvoir entraîner des modèles semblables aux modèles décrits dans ce chapitre, et de pouvoir comparer la performance des différents paramètres, j'ai développé un programme en Python permettant d'automatiser chaque étape de l'entraînement et de l'analyse des résultats d'un modèle. L'objectif de ce programme est de donner la possibilité aux personnes impliquées dans le projet QuChemPedia (REF QUCHEMPEDIA) de continuer à améliorer les modèles prédictifs et de valider leurs performances à l'issue de mon TER\footnote{Travail Encadré de Recherche}.\\

\par Ce programme se veut souple et facilement utilisable, c'est pourquoi il se base sur la lecture de fichiers JSON\footnote{http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf} décrivant les tâches à effectuer. Il pourrait toutefois être amélioré, notamment en utilisant des mécanismes du langage Python permettant d'encapsuler des arguments destinés à des fonctions spécifiques dans des dictionnaires. Cela permettrait de transmettre directement les paramètres lus dans les fichiers aux fonctions à qui ils sont destinés.

\subsection{Traitements disponibles}

Chaque traitement constitue une tâche. Plusieurs tâches peuvent être spécifiées dans un même fichier, elles sont alors exécutées séquentiellement. Les différentes tâches permises par le programme d'automatisation sont listées ci-dessous.

\paragraph{Séparation du jeu : } Cette tâche permet de séparer un jeu de données en un jeu d'entraînement et un jeu de validation en faisant appel à la bibliothèque Scikit-Learn\cite{sklearn}. On spécifie la proportion de données utilisées pour le jeu d'entraînement. la proportion de données utilisées pour le jeu de test en est déduite, et tous les exemples du jeu de données original sont donc utilisés. On spécifie en outre la graine aléatoire utilisée pour le mélange des données, de sorte que deux exécutions sur une même graine produisent les mêmes jeux de sortie.

\paragraph{Génération des entrées des modèles } Cette tâche permet de générer les entrées des modèles et les étiquettes (valeurs cibles) pour les jeux d'entraînement et de validation. On spécifie la taille minimale et la taille maximale des molécules dont on va extraire des exemples de liaisons, les numéros atomiques des atomes formant les couples des liaisons que l'on étudie, ainsi que le numéro atomique maximal pouvant être contenu dans les molécules des liaisons étudiées (REF DONNEES ENTREE MODELES DIST REL). On spécifie de plus les informations qui seront contenues dans la représentation des données, c'est à dire si l'on insère ou non la classe positionnelle, les masses atomiques et les distances (REF ENTREE DIST REL). Dans le cas où l'on insère les distances, on doit spécifier quelle fonction leur est appliquée, parmi la fonction identité, la fonction inverse et la fonction inverse du carré (REF FONCTIONS).\\
Enfin, concernant la taille des jeux de données générés, on peut choisir de spécifier le nombre de molécules dont seront extraits les exemples de liaisons. On peut également choisir de spécifier un nombre d'exemples souhaité pour chaque jeu. Le nombre de molécules dont seront extraites les exemples est alors calculé par proportionnalité de la représentation des liaisons. Pour cela, on calcule le nombre d'occurrences de la liaison sur un sous ensemble de 500 molécules, et on en déduit le nombre de molécules dont il faut extraire les données pour obtenir approximativement le nombre d'exemples souhaité.

\paragraph{Entraînement des modèles} Cette tâche permet d'entraîner un modèle prédictif. On spécifie le type de modèle (réseau de neurones artificiels, kernel ridge regression ou machine à vecteur de support), ainsi que les valeurs des paramètres associés au type de modèle entraîné.

\paragraph{Recherche par quadrillage} Cette tâche permet d'effectuer une recherche par quadrillage des hyper-paramètres d'un modèle (REF HYPERPARAMS), en faisant appel à la bibliothèque Scikit-Learn\cite{sklearn}. On spécifie la grille de paramètres, ainsi que le nombre de validations croisées. La fonction de recherche par quadrillage prenant en entrée un dictionnaire des paramètres, et l'expression des dictionnaires en Python étant très proche du format JSON, on donne directement la grille décrite dans le fichier à la fonction effectuant la recherche par quadrillage.

\paragraph{Représentation graphique des résultats}  À l'issue de l'entraînement d'un modèle, cette tâche permet de générer les trois types de représentation graphique des résultats. On spécifie de façon booléenne quelles représentations doivent être générées (distribution de l'erreur, erreur relative et prédictions), le chemin auquel le modèle a été sauvegardé ainsi que les éventuels paramètres permettant de recharger le modèle. Cette tâche affiche également les valeurs des métriques d'analyse des erreurs : moyenne, médiane, écart-type, erreur minimale, erreur maximale ainsi que l'erreur relative moyenne.\\
Notons que les légendes des représentations graphiques sont en anglais suite à une requête de Thomas Cauchy, qui souhaite les utiliser pour publier certains résultats.\\

\par Le développement de ce programme mérite d'être poursuivi. Cela permettra d'une part d'automatiser les traitements issus des futures évolutions des modèles, et d'autre part d'ajouter certaines tâches dont l'automatisation présenterait un intérêt. On peut notamment penser à une tâche automatisant la validation croisée des modèles (REF VALID CROISEE), qui permettrait de répondre aux interrogations découlant de certains résultats surprenants (REF DIST REL XY FONCTIONS), et plus généralement de valider la qualité et la constance des résultats que l'on obtient. On peut également penser à une tâche affichant les CID (REF BASES DONNEES MOL) des molécules sur lesquelles les modèles commettent les plus grosses erreurs. Cela permettrait potentiellement d'identifier d'éventuelles erreurs dans les calculs quantiques que nous utilisons en entrée, et également de comprendre quelles sont les géométries qui sont moins bien prédites par les modèles. C'est suite à une analyse semblable que nous avons mis au point les modèles appliquant une restriction aux atomes au voisinage le plus proche des liaisons (REF RESTRICT).
